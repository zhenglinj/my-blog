---
layout: post
title: "Java 笔记 - 1"
excerpt: "Java 笔记 -- 基础篇"
category: "technology"
draft: false
analytics: true
comments: true
tags: [java, notes]
---
{% include JB/setup %}

Java 笔记 -- 基础篇

---

## Java基础知识

Java入门教程：[Java教程](https://www.tutorialspoint.com/java/index.htm)  
开发环境教程：[IntelliJ IDEA 使用教程](http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/) [Eclipse 使用教程]()  
JDK源码：[JDK源码](http://grepcode.com/snapshot/repository.grepcode.com/java/root/jdk/openjdk/8-b132/)  

**重点熟悉：**

- Java关键字
- [Java基本数据类型](http://www.runoob.com/java/java-basic-datatypes.html)
- [Java String的使用](http://www.runoob.com/java/java-string.html)

## Java基础包源代码

> `java.lang.String` `java.lang.Integer` `java.lang.Long` `java.lang.Enum` `java.lang.ThreadLocal` `java.lang.ClassLoader` `java.net.URLClassLoader` `java.math.BigDecimal`

## Java集合框架

**Java集合框架**([参考这里](http://sparkandshine.net/java-collections-framework-overview-collection-list-set-queue-map/))用来表示和操作集合的统一框架，它包含接口，实现类以及一些编程辅助算法，具体位于`java.util`包下。

> `java.util.ArrayList` `java.util.LinkedList` `java.util.HashMap` `java.util.LinkedHashMap` `java.util.TreeMap` `java.util.HashSet` `java.util.LinkedHashSet` `java.util.TreeSet` `...`

Java集合框架(Java collections framework, JCF)是一组实现集合数据结构的类和接口。集合框架示意图如下(实际远比下图复杂)，图片来源于[这里](http://www.codejava.net/images/articles/javacore/collections/collections%20framework%20overview.png)
![Alt Text](/posts/images/collections-framework-overview_thumb.png )

## Java IO 和 Java NIO

Java的IO操作中有面向字节(Byte)和面向字符(Character)两种方式。

- 面向字节的操作为以8位为单位对二进制的数据进行操作，对数据不进行转换，这些类都是InputStream和OutputStream的子类。
- 面向字符的操作为以字符为单位对数据进行操作，在读的时候将二进制数据转为字符，在写的时候将字符转为二进制数据，这些类都是Reader和Writer的子类。

总结：以InputStream（输入）/OutputStream（输出）为后缀的是字节流；以Reader（输入）/Writer（输出）为后缀的是字符流。Java流类图结构如下：

![Alt Text](/posts/images/java_io_stream.jpg )

### Java NIO和IO的主要区别

| `java.io.*`    | `java.nio.*`         |
| :------------: | :------------------: |
| 面向流         | 面向缓冲             |
| 阻塞IO         | 非阻塞IO             |
| 无             | 选择器(Selectors)    |

参考 [Java NIO 入门](http://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html) [Java NIO与IO](http://ifeve.com/java-nio-vs-io/) 总结整理使用方法如下。

### Reactor模式

IO并发设计：Reactor模式与Proactor模式

## Java特性

### Java反射与javassist

反射与工厂模式 `java.lang.reflect.*`

### Java序列化

什么是序列化，为什么序列化 序列化与单例模式 `java.io.Serializable`

定义了如下的Employee类，该类实现了 Serializable 接口

```java
{% include_relative code/JavaSerializableDemo/src/Employee.java %}
```

一个类的对象要想序列化必须满足两个条件：

- 该类必须实现 java.io.Serializable 对象。
- 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。
  如果你想知道一个Java标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现java.io.Serializable接口。

**序列化和反序列化**

```java
{% include_relative code/JavaSerializableDemo/src/Main.java %}
```

输出结果：

```nohighlight
Serialized data is saved in ./employee.ser
Deserialized Employee from ./employee.ser ...
Name: Reyan Ali
Address: Phokka Kuan, Ambehta Peer
SSN: 0
Number: 101
Mailing a check to Reyan Ali Phokka Kuan, Ambehta Peer
```

### 虚引用，弱引用，软引用

`java.lang.ref.*` 实验这些引用的回收

### Java系统属性

`java.util.Properties`

### Annotation用法

`java.lang.annotation.*`

### JMS

`javax.jms.*`

### JMX

`java.lang.management.*` `javax.management.*`

### 泛型和继承，泛型和擦除

### 自动拆箱装箱与字节码

### 实现Callback

### java.lang.Void类使用

### Java Agent，premain函数

`java.lang.instrument`

### 单元测试

[Junit](http://junit.org/)

[Jmockit](https://code.google.com/p/jmockit/)

[djUnit](http://works.dgic.co.jp/djunit/)

### Java正则表达式

Java实现通过正则表达式提取一段文本中的电子邮件，并将@替换为#输出

`java.lang.util.regex.*`

### 常用的Java工具库

`commons.lang` `commons.*...` `guava-libraries` `netty`

### API & SPI

[http://en.wikipedia.org/wiki/Application_programming_interface](http://en.wikipedia.org/wiki/Application_programming_interface)

[http://en.wikipedia.org/wiki/Service_provider_interface](http://en.wikipedia.org/wiki/Service_provider_interface)

### Apache Maven

[Apache Maven Project](http://maven.apache.org/index.html)
[IntelliJ IDEA中Maven功能](http://www.youmeek.com/intellij-idea-part-xviii-maven/)

### 参考资料

JDK src.zip 源代码

[http://openjdk.java.net/](http://openjdk.java.net/)

[http://commons.apache.org/](http://commons.apache.org/)

[https://code.google.com/p/guava-libraries/](https://code.google.com/p/guava-libraries/)

[http://netty.io/](http://netty.io/)

[http://stackoverflow.com/questions/2954372/difference-between-spi-and-api](http://stackoverflow.com/questions/2954372/difference-between-spi-and-api)

[http://stackoverflow.com/questions/11404230/how-to-implement-the-api-spi-pattern-in-java](http://stackoverflow.com/questions/11404230/how-to-implement-the-api-spi-pattern-in-java)



## Java虚拟机JVM

### Java内存模型，Java内存管理，Java堆和栈

[http://www.jcp.org/en/jsr/detail?id=133](http://www.jcp.org/en/jsr/detail?id=133)

[Java内存模型FAQ](http://ifeve.com/jmm-faq/)

### Java垃圾回收机制

[深入理解java垃圾回收机制](http://www.cnblogs.com/sunniest/p/4575144.html)

### JVM各种参数及调优


### Java工具的使用

jps, jstack, jmap, jconsole, jinfo, jhat, javap, …

[http://kenai.com/projects/btrace](http://kenai.com/projects/btrace)

[http://www.crashub.org/](http://www.crashub.org/)

[https://github.com/taobao/TProfiler](https://github.com/taobao/TProfiler)

[https://github.com/CSUG/HouseMD](https://github.com/CSUG/HouseMD)

[http://wiki.cyclopsgroup.org/jmxterm](http://wiki.cyclopsgroup.org/jmxterm)

[https://github.com/jlusdy/TBJMap](https://github.com/jlusdy/TBJMap)

### Java诊断工具

[http://www.eclipse.org/mat/](http://www.eclipse.org/mat/)

[http://visualvm.java.net/oqlhelp.html](http://visualvm.java.net/oqlhelp.html)

**编写OutOfMemory, StackOverFlow程序**

> Heap OutOfMemory  
> Young OutOfMemory  
> MethodArea OutOfMemory  
> ConstantPool OutOfMemory  
> DirectMemory OutOfMemory  
> Stack OutOfMemory  
> Stack OverFlow  

[https://plumbr.eu/blog/memory-leaks/understanding-java-lang-outofmemoryerror](https://plumbr.eu/blog/memory-leaks/understanding-java-lang-outofmemoryerror)

**使用工具尝试解决以下问题，并写下总结**

当一个Java程序响应很慢时如何查找问题 当一个Java程序频繁FullGC时如何解决问题，如何查看垃圾回收日志 当一个Java应用发生OutOfMemory时该如何解决，年轻代、年老代、永久代解决办法不同，导致原因也不同

### 参考资料

[http://docs.oracle.com/javase/specs/jvms/se7/html/](http://docs.oracle.com/javase/specs/jvms/se7/html/)

[http://www.cs.umd.edu/~pugh/java/memoryModel/](http://www.cs.umd.edu/~pugh/java/memoryModel/)

[http://gee.cs.oswego.edu/dl/jmm/cookbook.html](http://gee.cs.oswego.edu/dl/jmm/cookbook.html)

## Java并发编程

### 阅读源代码

> `java.lang.Thread`  
> `java.lang.Runnable`  
> `java.util.concurrent.Callable` `java.util.concurrent.locks.ReentrantLock` `java.util.concurrent.locks.ReentrantReadWriteLock` `java.util.concurrent.atomic.Atomic*` `java.util.concurrent.Semaphore` `java.util.concurrent.CountDownLatch` `java.util.concurrent.CyclicBarrier` `java.util.concurrent.ConcurrentHashMap` `java.util.concurrent.Executors`

**线程的生命周期**

线程经过其生命周期的各个阶段。下图显示了一个线程完整的生命周期。

![Alt Text](/posts/images/java_thread.jpg)

- 新状态：一个新产生的线程从新状态开始了它的生命周期。它保持这个状态知道程序start这个线程。
- 运行状态：当一个新状态的线程被start以后，线程就变成可运行状态，一个线程在此状态下被认为是开始执行其任务
- 就绪状态：当一个线程等待另外一个线程执行一个任务的时候，该线程就进入就绪状态。当另一个线程给就绪状态的线程发送信号时，该线程才重新切换到运行状态。
- 休眠状态：由于一个线程的时间片用完了，该线程从运行状态进入休眠状态。当时间间隔到期或者等待的时间发生了，该状态的线程切换到运行状态。
- 终止状态：一个运行状态的线程完成任务或者其他终止条件发生，该线程就切换到终止状态。

### 创建一个线程

Java提供了两种创建线程方法：

- 通过实现Runable接口；
- 通过继承Thread类本身。

#### 通过实现Runnable接口来创建线程

[ThreadDemo]({{site.postsurl}}/code/JavaThread/ThreadDemo.java)

#### 通过继承Thread来创建线程

[ExtendThread]({{site.postsurl}}/code/JavaThread/ExtendThread.java)

### 学习使用线程池，自己设计线程池需要注意什么

### 线程安全

### 锁

什么是锁，锁的种类有哪些，每种锁有什么特点，适用场景是什么 在并发编程中锁的意义是什么

### synchronized的作用是什么，synchronized和lock

### sleep和wait

### wait和notify

### 什么是守护线程，守护线程和非守护线程的区别以及用法

### volatile关键字的理解

C++ volatile关键字和Java volatile关键字 happens-before语义 编译器指令重排和CPU指令重排

[http://en.wikipedia.org/wiki/Memory_ordering](http://en.wikipedia.org/wiki/Memory_ordering)

[http://en.wikipedia.org/wiki/Volatile_variable](http://en.wikipedia.org/wiki/Volatile_variable)

[java中volatile关键字的含义](http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html)

[Java 理论与实践: 正确使用Volatile 变量](http://www.ibm.com/developerworks/cn/java/j-jtp06197.html+&cd=2&hl=en&ct=clnk&gl=us)

[http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4](http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.4)

[http://preshing.com/20130702/the-happens-before-relation/](http://preshing.com/20130702/the-happens-before-relation/)

### 线程安全

如果为count加上volatile修饰是否能够做到线程安全？你觉得该怎么做是线程安全的？

```java
public class Sample {
  private static int count = 0;
  public static void increment() {
    count++;
  }
}
```

解释一下下面两段代码的差别

```java
// 代码1
public class Sample {
  private static int count = 0;
  synchronized public static void increment() {
    count++;
  }
}
// 代码2
public class Sample {
  private static AtomicInteger count = new AtomicInteger(0);
  public static void increment() {
    count.getAndIncrement();
  }
}
```

### 参考资料

[http://book.douban.com/subject/10484692/](http://book.douban.com/subject/10484692/)

[http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)
